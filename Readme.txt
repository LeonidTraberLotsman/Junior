	В каком порядке работает Unity.

У нас существуют геймобджекты в иерархии, а так же в каждом из них существуют компоненты.
Сначала выполняется update (обновление) для первого из них, потом для второго,
потом для третьего. Пока не завершится один апдейт, мы не перейдём в следующий. Если у
нас больше вычислений приходится на апдейт, то он будет дольше выполнятся. Так если у 
нас много объектов, то мы столкнёмся с тем что один такой проход по всей иерархии занимает
крайне много времени. Один такой проход делается каждый кадр, так если у нас
такой проход долгий, то кадр тоже долгий и в секунде таких кадров будет меньше.

	Существует специальный термин FPS, frames per seconds, кадров в секунду.Больше 
объектов - меньше кадров в секунду. Но иногда возникают ситуации, когда нам необходимо 
чего-то подождать. Как быть в таком случае? Если мы засунем такое ожидание в 
Update, то пока апдейт не закончится, не начнётся следующий, а пока не закончится они,
кадр не нарисуется. По факту, мы просто заморозим игровое время на заданное время.
	Но это несколько не тот функционал, который мы ожидаем. Скажем, нам нужна граната, 
которая взорвётся через заданное время, но мы хотим, чтобы мир игры продолжил обрабатываться.
Если применить вышеописанное, то в момент выдёргивания чеки, мир застынет на 3 секунды.
А потом граната взорвётся в руке главного героя.
	У нас есть особый инструмент для управления  данной системой. Корутина. Рутина -
это какой-то процесс. А приставка ко обычно переводится как "со", указывая на совместное
использование. Получается, что корутина - это сопроцесс, то есть некоторое действие, которое
не привязано к кадрам напрямую, а происходит исключительно паралельно. Он может встать на 
паузу на заданное время и сняться с неё через несколько кадров (может через час реального 
времени).
	Корутина запускается образом похожим на функцию, но вместо слова void, мы напишем
IEnumerator.

public IEnumerator testCoroutine(){
	yield return new WaitForSeconds(2);
	Debug.Log("test");
}

	Предлагаем создать новый скрипт в папке со скриптами и назвать его train.
В нём напишем тестовую короутину.

	Плавное движение

	Систематически у нас возникает необходимость в плавном движении, чтобы какой-то
объект двигался из одной точки в другую.  Мы можем обработать такую ситуацию разными 
методами. На прошлых занятиях у нас был метод работы через телепортацию, но он
нам достаточно слабо подходит.
	Мы хотим создать штуку, которая телепортирует объект достаточно быстро на
достаточно малые расстония, чтобы у наблюдателя складывалось впечатление, что он двигается.
Лучший способ взглянуть на это, разобрать на примере стандартной задачки из школы.

 	Школьная задача

	Есть село зайцево на 15 км трассы, есть село Куяново на 25 км трассы, у нас есть
телега, которая едет из зайцево в кукуево за 5 часов. Где она будет находится через
час, через два, через четыре? Для решения этой задачи нам для начала потребуется
найти скорость v. Скорость можно найти по формуле v=s/t, когда как время t нам известно 
и равно оно 5 часам. То путь мы можем найти посчитав расстояние между сёлами 25-15=10
Отсюда v=s/t=10/5=2 км/ч. Зная скорость мы можем начать искать координату, нам может
захотеться использовать формулу пути S=v*t, давайте попробуем. Через два часа после
начала пути t=2, v*t=2*2=4, получается, что телега с 15 км уехала на четвёртый, что
в другую сторону. Важно учитывать, что движение началось не с точки 0,
так что настоящая координата будет считать как x=15+v*t. То есть мы прибавляем путь
к стартовой точке.

	Цикл for

	В языке C# существует такая конструкция как цикл for. Он нужен, чтобы повторять
одно и тоже действие заданное количество раз. Нам как раз нужно повторять много раз
телепортацию. Каждое повторение цикла мы будем называть словом итерация. Каждая итерация
будет у нас длиться ровно один кадр.
	Далее всё пишем как в кейсе с автобусом.

void Start(){
	Vector3 A = transform.position;
	Vector3 B = new Vector3(0,3,7);
	StartCoroutine(Move(A,B,60));
}

public IEnumerator Move(Vector3 startPoint, Vector3 endPoint, int frames){
	Vector3 S = endPoint-startPoint; //находим путь, как условное расстояние между сёлами
	Vector3 v = S/frames;//находим скорость деля всё на время

	for(int i=0;i<frames;i++){
		transform.position=startPoint+i*v;
		yield return null;
	}
	transform.position= endPoint;
}